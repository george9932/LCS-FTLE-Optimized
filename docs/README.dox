/**

@mainpage Documentation

LCS is a library for performing [Lagrangian coherent structure](https://en.wikipedia.org/wiki/Lagrangian_coherent_structure) (LCS) analysis of flow field. [OpenMP](http://www.openmp.org/) is supported for parallelization.

It implements particle advection calculations for both discrete and continuous flow velocity data, and then uses finite-time Lyapunov exponent technique to obtain LCSs.

Suppose we have the flow map \f$\phi(t_0+T,\mathbf{x}_0,t_0)\f$ obtained after fluid particle advection, where \f$\mathbf{x}_0\f$ and \f$t_0\f$ are intial particle position and time, and \f$T\f$ is the advection time (integration time). Then, FTLE is defined as

\f[
    FTLE(\mathbf{x}_0,t_0) =\frac{1}{2T}\log\Big\{\lambda_{\max}\Big[\Big(\frac{\partial\phi}{\partial\mathbf{x}_0}\Big)^T\Big(\frac{\partial\phi}{\partial\mathbf{x}_0}\Big)\Big]\Big\},
\f]

where \f$\lambda_{\max}\f$ denotes the maximum eigenvalue of a matrix. Here, the matrix is called Cauchy-Green tensor.

## Example
### Continuous data
Here we show a demo of perform FTLE calculation for a double-gyre model. The implementation is included in continuous_double_gyre.cpp.

| pFTLE | nFTLE |
| ----- | ----- |
| ![pFTLE](https://raw.githubusercontent.com/stevenliuyi/lcs/master/demo/double_gyre/double_gyre_ftle_pos.png) | ![nFTLE](https://raw.githubusercontent.com/stevenliuyi/lcs/master/demo/double_gyre/double_gyre_ftle_neg.png) |

First, we create a ContinuousFlowField object, and set the grid shape as \f$(1000,500)\f$, the range of \f$x\f$-coordinate as $\f$(0,2)\f$, and the range of \f$y\f$-coordinate as \f$(0,1)\f$:

~~~~~~~~~~{.c}
ContinuousFlowField<double,VelocityFunction::DoubleGyreModel<double>,2> double_gyre(1000,500);
double_gyre.InitialPosition().SetAll(0,2,0,1);
~~~~~~~~~~

Next, we set each integration time step as \f$\Delta t=0.1\f$, and the number of steps as \f$n=200\f$:

~~~~~~~~~~{.c}
double_gyre.SetDelta(.1);
double_gyre.SetStep(200);
~~~~~~~~~~

Now we have done all the settings, and we could then simply advect the particles to obtain the flow map:

~~~~~~~~~~{.c}
double_gyre.Run();
~~~~~~~~~~

Finally, we could calculate FTLE based on the flow map we just obtained:

~~~~~~~~~~{.c}
FTLE<douuble,2> ftle(double_gyre);
ftle.Calculate();
ftle.WriteToFile("double_gyre_ftle_pos.txt");
~~~~~~~~~~

If we would like to obtain the flow map in backward direction and then calculate the negative FTLE corresponding to it, we could simply flip the advect direction and redo the calculations as:

~~~~~~~~~~{.c}
double_gyre.SetDirection(Direction::Backward);
double_gyre.SetInitialTime(20);
double_gyre.Run();

ftle.Calculate();
ftle.WriteToFile("double_gyre_ftle_neg.txt");
~~~~~~~~~~

*/
